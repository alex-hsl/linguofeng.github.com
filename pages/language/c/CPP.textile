---
layout: default
title: C++基础
description: 学习笔记
---

<section id="1">
    <div class="page-header">
        <h1>一、HelloWorld</h1>
    </div>
	<p>HelloWorld.cpp</p>
<pre>
#include <iostream>
using namespace std;

int main() {
    cout << "!!!Hello World!!!" << endl;
    return 0;
}
</pre>
</section>

<section id="2">
    <div class="page-header">
        <h1>二、变量与数据类型</h1>
    </div>
    <h3>数据类型</h3>
table(table table-bordered).
|_.名称|_=.字节数|_.描述|_.范围|
|@char@|=.1|字符（character）或整数（integer），8位|*有符号（signed）*: -128 到 127
*无符号（unsigned）*: 0 到 255|
|@short@|=.2|短整数（integer ），16位|*有符号（signed）*: -32768 到 32767
*无符号（unsigned）*: 0 到 65535|
|@long@|=.4|长整数（integer ），32位|*有符号（signed）*: -2147483648 到 2147483647
*无符号（unsigned）*: 0 到 4294967295|
|@int@|=.4|整数（integer），8位|*有符号（signed）*: -2147483648 到 2147483647
*无符号（unsigned）*: 0 到 4294967295 |
|@float@|=.4|浮点数（floating point number）|3.4e + / - 38 （7 个数字（7digits））|
|@double@|=.8|双精度浮点数（double precision floating point number）|1.7e + / - 308 (15 digits)|
|@long double@|=.8|长双精度浮点数（long double precision floating point number）|1.7e + / - 308 (15 digits)|
|@bool@|=.1|布尔Boolean值。它只能是真(true)或假(false)两值之一。|true 或 false|
|@wchar_t@|=.2|宽字符(Wide character) 。这是为存储两字节(2 bytes) 长的国际字符而设计的类型。|一个宽字符（1 wide characters）|
|\4.*备注* ：有符号类型(signed)可以表示 %(label label-info)正数% 和 %(label label-info)负数% ，而无符号类型(unsigned)只能表示 %(label label-info)正数% 和 %(label label-info)0% ，默认为 %(label label-info)signed% 。
定义一个有符号int类型： @signed int x;@
定义一个无符号int类型： @unsigned int y;@|
<h3>变量</h3>

<p>定义变量</p>
<pre>
// 声明变量
int a, b, c;

// 给变量赋值
a = 1;
b = 2;
c = 3;
</pre>

<p>变量初始化</p>
<pre>
int x = 12;     // 方式一
int y(52);      // 方式二
</pre>

<p>字符串</p>
<pre>
#include <string>       // 需要引用string头文件
...
string str1 = "Hello World1!";
string str2("Hello World2!");
...
</pre>
</section>

<section id="3">
    <div class="page-header">
        <h1>三、常量</h1>
    </div>
    <h3>什么是常量？</h3>
<pre>
5           // 一个整数 int
-5          // 有符号整数 int
5u          // 无符号整数 unsigned
5l          // 长整数 long
5ul         // 无符号长整数 unsigned long
5.214       // 双精度浮点数 double
6.002f      // 浮点数 float
3.127L      // 长双精度浮点数 long double
75          // 10进制数
0113        // 8进制数
0x4b        // 16进制数
'a'         // 字符 char
"abc"       // 字符串 string
'\n'        // 转义符号
L"abcdef"   // 宽字符 wchar_t
true        // 布尔值 bool
false       // 布尔值 bool

等都是常量.
</pre>
    <h3>常量的定义 <small>#define</small></h3>
<pre>
#define PI 3.14159
#define NEWLINE '\n' 
</pre>
    <h3>常量的声明 <small>const</small></h3>
<pre>
const int pathwidth = 100;
const char tabulator = '\t';
</pre>
</section>

<section id="4">
    <div class="page-header">
        <h1>四、输入输出</h1>
    </div>
    <p>输出</p>
<pre>
cout << "Hello"; // cout为输出流 <<为插入运算符，把Hello插入到cout输出流中
</pre>
    <p>输入</p>
<pre>
int age;
cin >> age;      // cin为输入流，接受输入的数据并通过>>给age变量
</pre>
    <p>输入字符串</p>
<pre>
#include <string>
...
string str;
getline(cin, str);
...
</pre>
    <p>字符串流（stringstream）</p>
<pre>
#include <string>
#include <sstream>
...
string str("123");
int x;
stringstream(str) >> x;     // 这个过程实现了字符串转换成数字
...
</pre>
</section>

<section id="5">
    <div class="page-header">
        <h1>五、控制结构与函数</h1>
    </div>
    <p>控制结构</p>
<pre>
if(true) {
    
} else {
    
}

while(true) {
    
}

do {
    
} while(true);

for(int i = 0; i < 10; i++) {
    
}
</pre>
    <p>结构控制</p>
<pre>
break           // 退出循环
continue        // 结束当前循环而继续进入下一个循环
goto            // 跳到

loop:           // 声明一个目标
cout << "abc"

goto loop;      // 跳到目标
</pre>
    <p>函数值传递与地址传递</p>
<pre>
// 值传递函数
int add1(int x, int y) {
    return x + y;
}

// 地址传递函数
int add2(int x, int y, int& result) {   // &地址符表示把地址作为参数传递
    result = x + y;
}

int main() {
    int result = 0;
    cout << result;     // result = 0

    result = add1(12, 98);
    cout << result;     // result = 110

    add2(12, 98, result)
    cout << result;     // result = 110
}
</pre>
    <p>函数的参数默认值</p>
<pre>
int add(int x, int y = 10) {
    return x + y;
}

cout << add(5);     // 输出15
cout << add(5, 20); // 输出25
</pre>
    <p>函数重载</p>
<pre>
int add(int x, int y) {
    return x + y;
}
float add(float x, float y) {
    return x + y;
}

cout << add(1, 11)      // 调用第一个函数
cout << add(1f, 11f)    // 调用第二个函数
</pre>
    <p>Inline内联函数，使用时编译</p>
<pre>
inline int add(int x, int y);

int main() {
    cout << add(12, 3);
}

int add(int x, int y) {
    return x + y;
}
</pre>
    <p>递归函数</p>
<pre>
int add(int x, int y) {
    int result = x + y;
    if(result < 1000000) {
        result = add(result, x);
    }
    return result;
}
</pre>
    <p>函数的声明，即在main函数后写函数</p>
<pre>
int add(int x, int y);  // 声明函数

int main() {
    cout << add(12, 33);
    return 0;
}

int add(int x, int y) {
    return x + y;
}
</pre>
</section>


<section id="6">
    <div class="page-header">
        <h1>六、高级数据类型</h1>
    </div>
    <p>数组</p>
<pre>
int is[5] = {12, 21, 51, 32, 95};         // 定义一个长度为5的数组
int iss[2][10];                           // 定义一个多维数组
</pre>
    <p>字符序列</p>
<pre>
char cs1[20];                             // 能保存20个字符的字符数组
char cs2[] = {'a', 'b', 'c', 'd', '\0'};  // 长度为5的字符数组
char cs3[] = "abcd";                      // 与cs2相同，自动添加\0

string str = cs3;                         // 成立
</pre>
    <p>指针</p>
<pre>
& -- 取地址符
* -- 取地址指向的内容

int i = 4;
int x = 0;
int * p;    // 定义一个p指针变量，用于保存指针地址，p的类型是int *，而不是int
p = &i;     // 取i的地址赋予指针变量p
x = *p;     // 取指针地址指向的内容赋予x
x == i;     // 成立
</pre>
    <p>指针与数组</p>
<pre>
int numbers[5];             // 初始化一个数组，同时数组名其实是一个指针常量，指向的是数组的第一个元素的地址
int * p;                    // 定义一个指针变量p
p = numbers;                // 成立，指针变量指向数组第一个元素的地址
*p = 10;                    // 使数组第一个元素等于10
p++;                        // 数组运算，移动指针到下一位，即数组的第二位的地址
*p = 20;                    // 使指针变量p指向的内容（数组第二个元素）等于20
p = &numbers[2];            // 使指针变量p等于数组第3个元素的地址
*p = 30;                    // 使指针变量p指向的内容（数组第三个元素）等于30
p = numbers + 3;            // 使指针变量p等于数组第一位+3即第4个元素的地址
*p = 40;                    // 使指针变量p指向的内容（数组第四个元素）等于40
p = numbers;                // 指针变量指向数组第一个元素的地址
*(p + 4) = 50;              // p+4移动指针到第五位，使其内容等于50
</pre>
    <p>指针的数学运算</p>
<pre>
假如：
char * p1 = 1000;
short * p2 = 2000;
long * p3 = 3000;
cout << p1++;        // 1001，char的长度是1
cout << p2++;        // 2002，short的长度是2
cout << p3++;        // 3004，long的长度是4

*p1++ => *(p1++)，这里是取1001地址指向的值，++比*运算符级别要高。
</pre>
    <p>指针的指针</p>
<pre>
char a;
char * b;
char ** c;

a = 'h';
b = &a;     // 把a的指针赋予指针变量b
c = &b;     // 把指针变量b的指针赋予c
</pre> 
    <p>void 指针</p>
<pre>
void increase(void * data, int psize) {      // void *表明data可以接收任意类型的指针
    if (psize == sizeof(char)) {             // 如果data是char *类型指针
        char * pchar;                        // 定义一个char *类型的指针变量
        pchar = (char *) data;               // 把void *类型指针转换成char *类型的指针并赋予pchar指针变量
        ++(*pchar);
    } else if (psize == sizeof(int)) {       // 如果data是int *类型指针
        int * pint;                          // 定义一个int *类型的指针变量
        pint = (int *) data;                 // 把void *类型指针转换成int *类型的指针并赋予pint指针变量
        ++(*pint);
    }
}

int main() {
    char a = 'x';
    int b = 12;
    increase(&a, sizeof(a));        // 结果是++(a)
    increase(&b, sizeof(b));        // 结果是++(b)
}
</pre>
    <p>空指针</p>
<pre>
int * p;
p = 0;
</pre>
    <p>函数指针</p>
<pre>
int add(int x, int y) {
    return x + y;
}

int (* addp)(int, int) = add;
cout << (* addp)(12, 24);
</pre>
</section>

<section id="7">
    <div class="page-header">
        <h1>七、动态内存</h1>
    </div>
    <p>new/new[]</p>
<pre>
int * p1 = new(nothrow) int;     // 给单个元素分配内存，nothrow关键字可以捕获异常
int * p2 = new int[5];           // 给数组分配内存

if(p1 == 0 || p2 == 0) {
    // 空指针
}
</pre>
    <p>delete/delete[]</p>
<pre>
delete p1;      // 删除单个元素分配的内存
delete[] p2;    // 删除数组分配的内存
</pre>
</section>

<section id="8">
    <div class="page-header">
        <h1>八、数据结构</h1>
    </div>
    <p>结构体</p>
<pre>
struct movies_t {
    string title;
    int year;
} mine, yours;

int main() {
    mine.title = "xxxxxx";
    mine.year = 1989;

    yours.title = "yyyyyy";
    yours.year = 2012;
}
</pre>
    <p>结构指针</p>
<pre>
movies_t * p;           // 定义一个movies_t结构类型的指针变量
p = &mine;              // 把movies_t结构类型的mine的地址赋予指针变量p
p -> title = "abcdef";  // 通过结构指针访问结构体内变量，等同于下面的方式
(*p).title = "xxx";
</pre>
    <p>结构嵌套</p>
<pre>
struct movies_t {
    string title;
    int year;
}
struct movies {
    string title;
    movies_t m;
} m1;

movies * p = &m1;

p -> title      => m1.title;
p -> m.title    => m1.m.title;
p -> m.year     => m1.m.year;
</pre>
</section>

<section id="9">
    <div class="page-header">
        <h1>九、其它数据类型</h1>
    </div>
    <p>typedef：自定义数据类型</p>
<pre>
typedef char C;             // 自定义一个char类型
typedef char * pChar;       // 自定义一个char *指针类型

C c = 'a';
pChar p = &c;
*p = 'b';
cout << c;  // 输出b
</pre>
    <p>union：联合，作用是通过不同的元素访问同一内存中不同的内容</p>
<pre>
union {
    long l;
    char c[4];
    struct {
        short a;
        short b;
    } s;
} u;

u.l     => 访问4个字节的内容
u.s.a   => 访问4个字节中的前两个字节的内容
u.s.b   => 访问4个字节中的后两个字节的内容
u.c[0]  => 访问4个字节中的第一个字节的内容
</pre>
</section>